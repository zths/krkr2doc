<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!-- generated by to_html.pl from interface.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>iTJSDispatch2 インターフェース</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关参考标准样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="主页" />
</head>
<body>
<h1><a id="id219" name="id219">iTJSDispatch2 とは</a>
</h1><div class="para"><div>
　iTJSDispatch2 は、TJS2 における「对象」に対するインターフェースを提供する抽象基本类です。<br />
　TJS2 の「对象」には函数对象、类、属性对象、数组(辞書数组) などが含まれます。<br />
　TJS2 に対するほとんどの操作はこのインターフェースを通じて行うことができます。<br />
<br />
　以下、このインターフェースを利用する側として説明をします。<br />
</div></div>



<h1><a id="id220" name="id220">序数による呼び出し</a>
</h1><div class="para"><div>
<br />
　iTJSDispatch2 の方法には、方法名の末尾が ByNum で終わる物があります。これは、序数による呼び出しを行うものであり、たとえば メンバ名に &quot;23&quot; を指定して FuncCall を呼ぶのと、序数に 23 を指定して FuncCallByNum を呼ぶのは等価です。<br />
　数组对象にアクセスする時に便利でしょう。<br />
<br />
　ByNum が末尾につく方法は、末尾に ByNum のつかない同名の方法の membername 引数と hint 引数がなく、代わりに tjs_int num があります。引数 num には序数を指定します。<br />
<br />
　以下、序数による呼び出しを行う方法关于は詳細な説明を省略します (末尾に ByNum のつかない同名の方法の説明を参照してください)。<br />
</div></div>








<h1><a id="id221" name="id221">AddRef</a>
</h1><div class="para"><div>
tjs_uint iTJSDispatch2::AddRef(void)<br />
<br />
　对象の参照カウンタをインクリメントします。<br />
　TJS2 の各对象は参照カウンタで管理されています。<br />
　戻り值はインクリメント後の参照カウンタの值ですが、この值を信用することは推奨されません。<br />
</div></div>








<h1><a id="id222" name="id222">Release</a>
</h1><div class="para"><div>
tjs_uint iTJSDispatch2::Release(void)<br />
<br />
　对象の参照カウンタをデクリメントします。<br />
　戻り值はデクリメント後の参照カウンタの值で、0 が戻ったときは对象が解放されたことを表します。しかし、この值を信用することは推奨されません。<br />
</div></div>












<h1><a id="id223" name="id223">FuncCall</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::FuncCall(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char * membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int numparams,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant **param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　函数呼び出しを行います。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　操作対象とするメンバ名です。<br />
　NULL の場合は、この对象自身に対する操作になります。この場合は、この对象は函数の機能を持っている必要があります。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　「<a id="id224" name="id224" class="targanchor"><dfn>ヒント</dfn></a>」を格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントは、２回目以降の同じメンバ名に対する検索を高速に行えるようにするためのものです。hint に tjs_uint32 型の变量へのポインタを指定すると、そこにヒントとなる数值が書き込まれます。２回目以降はその数值を参考にしてメンバを検索します。参考にする程度ですので、ヒントの初期值はどのような值であってもかまいません ( 0 が推奨されます )。また、このような仕組みのため、ヒントとそれに対するメンバ名は１対１で対応しているとより効率的です (tTJSString 型はこのヒントのための機構を持っています)。<br />
　对象によっては、ヒントを利用する機構を持っていないかも知れません。</dd>

<dt>tTJSVariant *result</dt>
<dd>　函数を呼び出した結果を格納するための tTJSVariant 型へのポインタを指定します。<br />
　結果が必要ない場合は NULL を指定してかまいません。</dd>

<dt>tjs_int numparams</dt>
<dd>　函数に渡す引数の数を指定します。</dd>

<dt>tTJSVariant **param</dt>
<dd>　函数に渡す引数のポインタの数组を渡します。引数がない場合は NULL でかまいません。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　函数が実行されるコンテキスト (this 对象) を指定します。</dd></dl></div></div>




<h1><a id="id225" name="id225">FuncCallByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::FuncCall(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int numparams,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant **param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数による函数呼び出しを行います。<br />
</div></div>



<h1><a id="id226" name="id226">PropGet</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::PropGet(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char * membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　属性やメンバ变量の值の取得を行います。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　操作対象とするメンバ名です。<br />
<br />
　NULL の場合は、この对象自身に対する操作になります。この場合は、この对象は属性取得の機能を持っている必要があります。<br />
　この引数が NULL でも成功する对象は、属性对象と見なされます。通常、このような属性对象が他の对象のメンバになった場合は、この属性对象自体ではなく、その属性对象に対して PropGet を行った結果が用いられます。この動作は呼び出しフラグに TJS_IGNOREPROP を指定することでバイパスすることができます。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>tTJSVariant *result</dt>
<dd>　結果を格納するための tTJSVariant 型へのポインタを指定します。NULL は許されません。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　この方法が実行されるコンテキスト (this 对象) を指定します。</dd></dl></div></div>


<h1><a id="id227" name="id227">PropGetByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::PropGetByNum(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数による、属性やメンバ变量の值の取得を行います。<br />
</div></div>






<h1><a id="id228" name="id228">PropSet</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::PropSet(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char *membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tTJSVariant *param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　属性やメンバ变量の值の设置を行います。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　操作対象とするメンバ名です。<br />
<br />
　NULL の場合は、この对象自身に対する操作になります。この場合は、この对象は属性设置の機能を持っている必要があります。<br />
　この引数が NULL でも成功する对象は、属性对象と見なされます。通常、このような属性对象が他の对象のメンバになった場合は、この属性对象自体ではなく、その属性对象に対して PropSet が呼ばれます。この動作は呼び出しフラグに TJS_IGNOREPROP を指定することでバイパスすることができます。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>const tTJSVariant *param</dt>
<dd>　设置する值を表す tTJSVariant 型の变量へのポインタを指定します。NULL は許されません。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　この方法が実行されるコンテキスト (this 对象) を指定します。</dd></dl></div></div>

<h1><a id="id229" name="id229">PropSetByVS</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::PropSetByVS(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariantString *membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tTJSVariant *param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　属性やメンバ变量の值の设置を行います。PropSet と異なるのは、メンバ名が tTJSVariantString により参照される点です。内部的に用いられます。tTJSVariantString は同じ字符串用メモリ領域を、複数の字符串对象が共有して使う機構を持っているため、この方法を介して属性の设置 (对象内へのメンバの作成) を行うと、メンバ名に使用される字符串メモリ領域用メモリの増加を防ぐことができます。<br />
　この方法を実装しない場合は TJS_E_NOTIMPL を返してください。代わりに PropSet が使用されます。また、この方法を呼び出して TJS_E_NOTIMPL が返された場合は、PropSet を代わりに使うように実装してください。<br />
<br />
</div></div>





<h1><a id="id230" name="id230">PropSetByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::PropSetByNum(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tTJSVariant *param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数による、属性やメンバ变量の值の设置を行います。<br />
</div></div>






<h1><a id="id231" name="id231">GetCount</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::GetCount(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char *membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　对象が保持しているメンバの数を返します。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_int *result</dt>
<dd>　結果を格納するための变量へのポインタを指定します。NULL は許されません。</dd>

<dt>const tjs_char * membername</dt>
<dd>　対象とするメンバの名前を指定します。<br />
　NULL の場合、この对象自身の保持しているメンバの数が帰ります。<br />
　メンバ名が指定された場合、もし、そのメンバが对象ならば、その对象の保持しているメンバの数を返します。指定されたメンバが对象型でなかった場合は失敗します。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　この方法が実行されるコンテキスト (this 对象) を指定します。<br />
　この引数は、通常、意味を持ちません(無視されます)。</dd></dl></div></div>



<h1><a id="id232" name="id232">GetCountByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::GetCount(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　GetCount の序数バージョンです。<br />
</div></div>


<h1><a id="id233" name="id233">DeleteMember</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::DeleteMember(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char *membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　メンバの削除を行います。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　対象とするメンバの名前を指定します。NULL は許されません。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　この方法が実行されるコンテキスト (this 对象) を指定します。<br />
　この引数は、通常、意味を持ちません(無視されます)。</dd></dl></div></div>





<h1><a id="id234" name="id234">DeleteMemberByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::DeleteMemberByNum(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数によりメンバの削除を行います。<br />
</div></div>


<h1><a id="id235" name="id235">EnumMembers</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::EnumMembers(<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariantClosure *callback,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　对象内のメンバを列挙します。<br />
　callback にはコールバック函数を指定できますが、現バージョンではコールバック函数内でこの对象のメンバの作成や削除を行った場合の動作は保証されません。<br />
<br />
　引数は以下の通りです。<br />
　<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです。呼び出しフラグは、下記のフラグのビット論理和あるいは 0(ゼロ) を指定してください。<br />
<dl>
<dt>TJS_IGNOREPROP</dt>
<dd>　属性アクセスを無効化します。メンバを列挙し、かつ值を取得する場合、このフラグが指定されていると、メンバが属性の場合は属性对象そのものが得られます。このフラグを指定しなかった場合は、属性对象を通して得られた值が得られます。<br />
</dd>
<dt>TJS_ENUM_NO_VALUE</dt>
<dd>　值を取得しません。このフラグが指定されていると、コールバック函数に渡される引数は 2 つになります。指定されていると 3 つになります。<br />
</dd></dl></dd>
<dt>tTJSVariantClosure *callback</dt>
<dd>　コールバック函数を指定します。<br />
　このコールバック函数は、メンバ一つにつき一回ずつ、callback-&gt;FuncCall が呼び出されます。<br />
　函数には２つ(TJS_ENUM_NO_VALUEを指定した場合)あるいは３つ(TJS_ENUM_NO_VALUEを指定しなかった場合)の引数が渡されます。<br />
<ul><li>第１引数は字符串型になり、メンバ名です</li><li>第２引数は整数型になり、そのメンバのフラグです。TJS_HIDDENMEMBER あるいは TJS_STATICMEMBER のビット論理和の組み合わせ、あるいは 0 が指定されます</li><li>第３引数はTJS_ENUM_NO_VALUEを指定しなかった場合にのみ存在し、そのメンバの值を表します</li></ul></dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　この方法が実行されるコンテキスト (this 对象) を指定します。<br />
　この引数は、TJS_IGNOREPROP フラグが指定されない場合、属性对象が実行されるデフォルトのコンテキストとなります。<br />
</dd></dl>


</div></div>







<h1><a id="id236" name="id236">Invalidate</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::Invalidate(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char *membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　無効化を行います。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　対象とするメンバの名前を指定します。<br />
　NULL の場合、この对象自身が無効化されます。<br />
　メンバ名が指定された場合、もし、そのメンバが对象ならば、その对象が無効化されます。指定されたメンバが对象型でなかった場合は失敗します。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　この方法が実行されるコンテキスト (this 对象) を指定します。<br />
　この引数は、通常、意味を持ちません(無視されます)。</dd></dl></div></div>


<h1><a id="id237" name="id237">InvalidateByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::InvalidateByNum(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
序数により無効化を行います。<br />
</div></div>




<h1><a id="id238" name="id238">IsValid</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::IsValid(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char *membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　对象が有効かどうかを調べます。<br />
　有効の場合は TJS_S_TRUE が、向こうの場合は TJS_S_FALSE が戻ります。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　対象とするメンバの名前を指定します。<br />
　NULL の場合、この对象自身の有効性を調べることができます。<br />
　メンバ名が指定された場合、もし、そのメンバが对象ならば、その对象の有効性を調べることができます。指定されたメンバが对象型でなかった場合は失敗します。
</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　この方法が実行されるコンテキスト (this 对象) を指定します。<br />
　この引数は、通常、意味を持ちません(無視されます)。</dd></dl></div></div>






<h1><a id="id239" name="id239">IsValidByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::IsValidByNum(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数により、对象が有効かどうかを調べます。<br />
</div></div>





<h1><a id="id240" name="id240">CreateNew</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::CreateNew(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char * membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 **result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int numparams,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant **param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　新規对象を作成します。<br />
　この方法は FuncCall 方法に似て、对象を新規作成するために引数を渡すことができます。<br />
　对象の雛形となる、いわゆる「类对象」はこの方法を実装している必要があります。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　操作対象とするメンバ名です。<br />
　NULL の場合は、この对象自身に対する操作になります。この場合は、この对象は、新に对象を新規作成する機能を持っている必要があります。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>iTJSDispatch2 **result</dt>
<dd>　新しく作成した对象を格納するための iTJSDispatch * 型へのポインタを指定します。NULL は許されません。</dd>

<dt>tjs_int numparams</dt>
<dd>　对象を新規作成する際に渡す引数の数を指定します。</dd>

<dt>tTJSVariant **param</dt>
<dd>　对象を新規作成する際に渡す引数のポインタの数组を渡します。引数がない場合は NULL でかまいません。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　对象を新規作成する際に実行されるコンテキスト (this 对象) を指定します。</dd></dl></div></div>




<h1><a id="id241" name="id241">CreateNewByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::CreateNew(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 **result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int numparams,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant **param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数により新規对象を作成します。<br />
</div></div>







<h1><a id="id242" name="id242">IsInstanceOf</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::IsInstanceOf(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char * membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char * classname,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　对象が、特定の类のインスタンスであるかどうかを調べます。<br />
　类名は classname 引数に字符串で渡されます。<br />
　TJS2 の instanceof 演算子により参照されます。<br />
　成功した場合、指定された类のインスタンスである場合は TJS_S_TRUE が、そうでない場合は TJS_S_FALSE が帰ります。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです(下記参照)。</dd>

<dt>const tjs_char * membername</dt>
<dd>　操作対象とするメンバ名です。<br />
　NULL の場合は、この对象自身に対する操作になります。この場合は、この对象は、新に对象を新規作成する機能を持っている必要があります。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>const tjs_char *classname</dt>
<dd>　类名を字符串で指定します。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　对象を新規作成する際に実行されるコンテキスト (this 对象) を指定します。</dd></dl></div></div>



<h1><a id="id243" name="id243">IsInstanceOfByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::IsInstanceOfByNum(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char * classname,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数により、对象が、特定の类のインスタンスであるかどうかを調べます。<br />
</div></div>



<h1><a id="id244" name="id244">Operation</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::Operation(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tjs_char *membername,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 *hint,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tTJSVariant *param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　メンバに対して演算を行います。演算の種類は flag で指定します。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです。下記の通常の呼び出しフラグの他、演算の種類を指定するために以下のフラグのいずれかをビットORで付加する必要があります。<br />
<br />
　なお、この説明中で v はメンバの值、p は param 引数で渡す参数を表します。<br />
<br />
<dl>
<dt>TJS_OP_BAND</dt>
<dd>ビット AND 演算<br />
v &amp;= p</dd>

<dt>TJS_OP_BOR</dt>
<dd>ビット OR 演算<br />
v |= p</dd>

<dt>TJS_OP_BXOR</dt>
<dd>ビット XOR 演算<br />
v ^= p</dd>

<dt>TJS_OP_SUB</dt>
<dd>減算<br />
v -= p</dd>

<dt>TJS_OP_ADD</dt>
<dd>加算<br />
v += p</dd>

<dt>TJS_OP_MOD</dt>
<dd>モジュラ<br />
v %= p</dd>

<dt>TJS_OP_DIV</dt>
<dd>実数除算<br />
v /= p</dd>

<dt>TJS_OP_IDIV</dt>
<dd>整数除算<br />
v \= p</dd>

<dt>TJS_OP_MUL</dt>
<dd>乗算<br />
v *= p</dd>

<dt>TJS_OP_LOR</dt>
<dd>論理 OR<br />
v = v || p</dd>

<dt>TJS_OP_LAND</dt>
<dd>論理 AND<br />
v = v &amp;&amp; p</dd>

<dt>TJS_OP_SAR</dt>
<dd>算術右シフト<br />
v &gt;&gt;= p</dd>

<dt>TJS_OP_SAL</dt>
<dd>算術左シフト<br />
v &lt;&lt;= p</dd>

<dt>TJS_OP_SR</dt>
<dd>ビット左シフト<br />
v &gt;&gt;&gt;= p</dd>

<dt>TJS_OP_INC</dt>
<dd>インクリメント<br />
v++<br />
param 引数は無視されます</dd>

<dt>TJS_OP_DEC</dt>
<dd>デクリメント<br />
v--<br />
param 引数は無視されます</dd></dl>
</dd>

<dt>const tjs_char * membername</dt>
<dd>　操作対象とするメンバ名です。NULL は許されません。</dd>

<dt>tjs_uint32 *hint</dt>
<dd>　ヒントを格納するための变量の領域を指定します。NULLでもかまいません。<br />
　ヒントの説明关于は FuncCall の説明を参照してください。</dd>

<dt>tTJSVariant *result</dt>
<dd>　演算の結果を格納するための tTJSVariant 型の变量へのポインタを指定します。NULL でかまいません。</dd>

<dt>tTJSVariant *param</dt>
<dd>　演算の参数を指定します。演算の種類に TJS_OP_INC または TJS_OP_DEC を指定した場合は NULL でかまいません。</dd>

<dt>iTJSDispatch2 *objthis</dt>
<dd>　演算が実行されるコンテキストを指定しますが、通常無視されます。</dd></dl></div></div>




<h1><a id="id245" name="id245">OperationByNum</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::OperationByNum(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant *result,<br />
&nbsp;&nbsp;&nbsp;&nbsp;const tTJSVariant *param,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSDispatch2 *objthis<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　序数を用いて、メンバに対して演算を行います。<br />
</div></div>



<h1><a id="id246" name="id246">NativeInstanceSupport</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::NativeInstanceSupport(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_int32 classid,<br />
&nbsp;&nbsp;&nbsp;&nbsp;iTJSNativeInstance **pointer<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　对象にネイティブコードのインスタンスを関連づけたり、对象からネイティブコードのインスタンスを取得したりします。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグを指定します。<br />
　以下のいずれかの值を指定する必要があります。<br />
<br />
<dl>
<dt><a id="id247" name="id247" class="targanchor"><dfn>TJS_NIS_REGISTER</dfn></a></dt>
<dd>　*pointer で示したネイティブコードのインスタンスを登録します。ネイティブコードの类の識別には classid を用います。</dd>


<dt><a id="id248" name="id248" class="targanchor"><dfn>TJS_NIS_GETINSTANCE</dfn></a></dt>
<dd>　classid で指定した 类ID を持つネイティブコードのインスタンスを *pointer に書き込みます。</dd></dl></dd>


<dt>tjs_int32 classid</dt>
<dd>　ネイティブコードの类 ID を指定します。<br />
　ネイティブコードの类 ID の管理には TJSRegisterNativeClass
TJSFindNativeClassID
TJSFindNativeClassName を使用することができますが、通常は これらの処理はネイティブコードを記述するための
支援コード群 ( tjsNative.cpp/tjsNative.h に記述 ) で自動的に処理されます。</dd>


<dt>iTJSNativeInstance **pointer</dt>
<dd>　ネイティブコードのインスタンスを渡したり、受け取ったりするために、iTJSNativeInstance *型の变量へのポインタを指定します。</dd></dl></div></div>


<h1><a id="id249" name="id249">ClassInstanceInfo</a>
</h1><div class="para"><div>
tjs_error iTJSDispatch2::ClassInstanceInfo(<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint32 flag,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tjs_uint num,<br />
&nbsp;&nbsp;&nbsp;&nbsp;tTJSVariant *value<br />
&nbsp;&nbsp;&nbsp;&nbsp;)<br />
<br />
　IsInstanceOf 方法で使用する、类のインスタンス信息を操作する方法です。<br />
　对象がどの类のインスタンスかを識別するために类名を追加したり、对象がどの类のインスタンスかを調べるために类を列挙することができます。<br />
<br />
　引数は以下の通りです。<br />
<br />
<dl>
<dt>tjs_uint32 flag</dt>
<dd>　呼び出しフラグです。以下のフラグのいずれかを指定します。<br />
<br />
<dl>
<dt><a id="id250" name="id250" class="targanchor"><dfn>TJS_CII_ADD</dfn></a></dt>
<dd>　インスタンス信息を追加します。<br />
　value には类名 (字符串) の格納された tTJSVariant 型の变量へのポインタを渡します。<br />
　num 引数は無視されます。</dd>

<dt><a id="id251" name="id251" class="targanchor"><dfn>TJS_CII_GET</dfn></a></dt>
<dd>　インスタンス信息を取得します。<br />
　num 引数には 0 から始まる 整数を指定します。设置されているインスタンス信息の数を超えて num を指定すると TJS_E_FAIL が戻ります。<br />
　value には类名を受け取るための、tTJSVariant 型の变量へのポインタを渡します。</dd></dl></dd>


<dt>tjs_uint num</dt>
<dd>　flag に TJS_CII_GET を指定した場合の序数を指定します。</dd>


<dt>tTJSVariant *value</dt>
<dd>　flag に TJS_CII_ADD を指定した場合は、类名が格納された tTJSVariant 型の变量へのポインタを渡します。<br />
　flag に TJS_CII_GET を指定した場合は、类名を受け取るための tTJSVariant 型の变量へのポインタを渡します。</dd></dl>
</div></div>


<h1><a id="id252" name="id252">呼び出しフラグ</a>
</h1><div class="para"><div>

　呼び出しフラグです。<br />
　以下の值のビットORによる組み合わせを指定することができます。<br />
<br />
<dl>
<dt>TJS_MEMBERENSURE</dt>
<dd>　指定されたメンバ名が見つからなかった場合、強制的にメンバを作成します。PropSet に対する呼び出しフラグとして有効です。
 )</dd>

<dt>TJS_MEMBERMUSTEXIST</dt>
<dd>　指定されたメンバ名が見つからなかった場合、错误にします。これは、Dictionary や Array のような、メンバが見つからない場合にデフォルトで void を返すような对象に対して有効です (そのような对象でない場合は、メンバが見つからない場合はデフォルトで错误になります)。</dd>




<dt>TJS_IGNOREPROP</dt>
<dd>　属性操作をバイパスします。<br />
　TJS2 の对象は通常、指定されたメンバが对象で、かつ、その对象に対して PropSet や PropGet が成功する場合 (属性对象の場合)、そのメンバに対する PropSet や PropGet の結果を、そのメンバの代わりと見なして使います。<br />
　このフラグを指定すると、このような処理をバイパスするため、指定されたメンバが属性对象であっても、属性对象そのものに対する操作になります。</dd>

<dt>TJS_HIDDENMEMBER</dt>
<dd>　このフラグを指定してメンバを作成すると、メンバは不可視になります。对象によってはサポートされていないこともあり得ます。</dd>
<dt>TJS_STATICMEMBER</dt>
<dd>　このフラグを指定してメンバを作成すると、メンバはスタティック (実行コンテキストに依存しない) となります。对象によってはサポートされていないこともあり得ます。</dd>
</dl></div></div>

<h1><a id="id253" name="id253">tjs_error</a>
</h1><div class="para"><div>
　tjs_error は、iTJSDispatch2 の各方法 ( AddRef と Release を除く ) が返す错误型です。<br />
　以下の值を採ります。また、ここに載ってない值でも、值が負の場合は错误と見なす必要があります。これらを判断するために TJS_SUCCEEDED および TJS_FAILED マクロを使用することができます。<br />
<br />
<dl>
<dt><a id="id254" name="id254" class="targanchor"><dfn>TJS_E_MEMBERNOTFOUND</dfn></a></dt>
<dd>　指定されたメンバが見つかりません。</dd>


<dt><a id="id255" name="id255" class="targanchor"><dfn>TJS_E_NOTIMPL</dfn></a></dt>
<dd>　呼び出そうとした機能は未実装です。</dd>


<dt><a id="id256" name="id256" class="targanchor"><dfn>TJS_E_INVALIDPARAM</dfn></a></dt>
<dd>　不正な引数です。</dd>


<dt><a id="id257" name="id257" class="targanchor"><dfn>TJS_E_BADPARAMCOUNT</dfn></a></dt>
<dd>　引数の数が不正です。</dd>


<dt><a id="id258" name="id258" class="targanchor"><dfn>TJS_E_INVALIDTYPE</dfn></a></dt>
<dd>　函数ではないか属性の種類が違います。<br />
　函数でない物を呼び出そうとした場合や、属性でない物を属性として扱おうとしたときにこの值が帰ります。</dd>


<dt><a id="id259" name="id259" class="targanchor"><dfn>TJS_E_INVALIDOBJECT</dfn></a></dt>
<dd>　对象はすでに無効化されています。</dd>


<dt><a id="id260" name="id260" class="targanchor"><dfn>TJS_E_ACCESSDENYED</dfn></a></dt>
<dd>　読み込みあるいは書き込み専用属性に対して行えない操作をしようとしました。</dd>


<dt><a id="id261" name="id261" class="targanchor"><dfn>TJS_E_NATIVECLASSCRASH</dfn></a></dt>
<dd>　実行コンテキストが違います。<br />
　ネイティブコードで実装された方法を、そのネイティブコードで扱えないコンテキスト (違う类の对象上など) で実行しようとしたときにこの值が帰ります。</dd>


<dt><a id="id262" name="id262" class="targanchor"><dfn>TJS_S_TRUE</dfn></a></dt>
<dd>　错误ではありませんが、結果が「真」であることを示します。</dd>


<dt><a id="id263" name="id263" class="targanchor"><dfn>TJS_S_FALSE</dfn></a></dt>
<dd>　错误ではありませんが、結果が「偽」であることを示します。</dd>


<dt><a id="id264" name="id264" class="targanchor"><dfn>TJS_S_OK</dfn></a></dt>
<dd>　错误が発生しなかった場合に、通常、この值が帰ります。</dd>


<dt><a id="id265" name="id265" class="targanchor"><dfn>TJS_E_FAIL</dfn></a></dt>
<dd>　未定义の错误が発生した場合、この值が帰ります。</dd>


<dt><a id="id266" name="id266" class="targanchor"><dfn>TJS_FAILED</dfn></a>(x)</dt>
<dd>　x が错误の值の場合に真になるマクロです。</dd>

<dt><a id="id267" name="id267" class="targanchor"><dfn>TJS_SUCCEEDED</dfn></a>(x)</dt>
<dd>　x が错误でない值の場合に真になるマクロです。</dd></dl><br />

<br />
　错误定義、および関連するマクロは tjsErrorDef.h に記述されています。<br />
　また、错误ではなく (C++における) 実行時例外が投げられる場合があります。プログラミングに関しては、実行時例外を十分に考慮する必要があります。<br />
</div></div>

	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
