<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!-- generated by to_html.pl from class.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>类</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关参考标准样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="主页" />
</head>
<body>
<h1><a id="id47" name="id47">类</a>
</h1><div class="para"><div>
　类は、对象を作成するときの雛形となるものです。类に属する变量をメンバ变量、类に属する函数をメンバ函数、あるいは方法と呼び、类に属する属性はメンバ属性と呼びます。<br />
<br />
　类は基本的には以下のようにして宣言します。<br />

<br />
<code class="bq"><a id="id48" name="id48" class="targanchor"><dfn>class</dfn></a>&nbsp;classname<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;メンバやメンバ方法やメンバ属性を記述</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;classname()&nbsp;<span class="comment">//&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;<a id="id49" name="id49" class="targanchor"><dfn>finalize</dfn></a>()<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
</code>
<br />

<br />
　类名には識別子を指定します。<br />
<br />
　类内には、その类が作成されたときにメンバとなる变量や方法、属性を記述します。<br />
<br />
　类内には、类と同名の方法が必ず一つあり、<a id="id50" name="id50" class="targanchor"><dfn>コンストラクタ</dfn></a>と呼ばれます。これは、 <a id="id51" name="id51" class="targanchor"><dfn>new</dfn></a> 演算子を使用して对象を作成するとき、この函数が new 演算子の引数を伴って呼び出されます。<br />
<br />
　类内には同様に、finalize という特殊な方法があります。これは、对象が消滅するときに呼ばれる方法で、省略可能です。書かなくてもかまいません。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;test()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;ここに、对象が作成されるときに処理する内容を書く</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable&nbsp;=&nbsp;0;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;finalize&nbsp;方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;ここに、对象が破棄されるときに処理する内容を書く</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.inform(variable);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable;&nbsp;<span class="comment">//&nbsp;メンバ变量</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;prop&nbsp;<span class="comment">//&nbsp;メンバ属性</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getter()&nbsp;{&nbsp;return&nbsp;variable;&nbsp;}&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

<br />
类に対して instanceof 演算子を &quot;Class&quot; を伴って使用した場合は真になります(上記の例で言うと、test instanceof &quot;Class&quot; は真)。<br />
</div></div>
<h1><a id="id52" name="id52">对象の作成</a>
</h1><div class="para"><div>
　宣言した类の对象を作成するには new 演算子を使います。<br />
　new 演算子の後には、函数呼び出しと同様に、类名と、コンストラクタに渡す引数を指定します。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable1&nbsp;=&nbsp;getValue();&nbsp;<span class="comment">//&nbsp;メンバ变量の初期化</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test(arg1,&nbsp;arg2)&nbsp;<span class="comment">//&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;ここでは&nbsp;new&nbsp;演算子で指定した引数が&nbsp;arg1&nbsp;と&nbsp;arg2&nbsp;にわたっている</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;newobject&nbsp;=&nbsp;new&nbsp;Test(1,&nbsp;2);&nbsp;<span class="comment">//&nbsp;引数に&nbsp;1,&nbsp;2&nbsp;を渡して&nbsp;test&nbsp;类の对象を作成</span><br />
</code>
<br />

<br />
　类が作成されるときの処理の順番は以下の通りです。<br />
<br />
<ol><li>まず空の对象が作成される</li><li>方法、属性が登録される</li><li>メンバ变量が作成される ( このとき初期化が必要な变量は初期化される )</li><li>コンストラクタが実行される</li></ol><br /><div class="note"><div class="notehead"><span class="noteheadspan">Note</span></div>
　コンストラクタへの引数がない場合であっても、new 演算子の  ( ) を省略することはできません。 JavaScript のように new Test と書くことはできません。new Test( ) と書く必要があります。<br />
</div><br />
<br />
　特に、类の方法や属性内でその类の对象を作成する場合、あるいはその类のスーパー类の对象を作成する場合、以下のようにすると错误になります。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()&nbsp;<span class="comment">//&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;func()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Test();&nbsp;<span class="comment">//&nbsp;错误</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

<br />
　なぜならば、类の方法や属性内で Test と単に書くと、类である Test よりもそのコンストラクタの Test の方がスコープ的に近いため、コンストラクタの Test 参照されてしまうからです。この場合はこれを避けるために、以下のように明示的に global. を使用する必要があります ( 类は global に登録されるからです )。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()&nbsp;<span class="comment">//&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;func()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;global.Test();&nbsp;<span class="comment">//&nbsp;これならば&nbsp;OK</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

</div></div>
<h1><a id="id53" name="id53">对象の無効化</a>
</h1><div class="para"><div>
　TJS2 では、对象が削除される際、对象の<a id="id54" name="id54" class="targanchor"><dfn>無効化</dfn></a>と对象の削除、という２つの段階を踏みます。<br />
　对象が無効化されるとき、 finalize 方法が呼ばれ、その对象は無効であるというマークがつけられます。以降のその对象へのアクセスはすべて失敗し、例外が発生するようになります。对象が無効化されているかどうかは <a id="id55" name="id55" class="targanchor"><dfn>isvalid</dfn></a> 演算子で調べることができます。<br />
<br />
　对象は <a id="id56" name="id56" class="targanchor"><dfn>invalidate</dfn></a> 演算子で無効化することができます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable&nbsp;=&nbsp;new&nbsp;AnotherClass();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;finalize&nbsp;方法は無効化された時に呼ばれる</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidate&nbsp;variable;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;object&nbsp;=&nbsp;new&nbsp;Test();&nbsp;<span class="comment">//&nbsp;对象を作成</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;invalidate&nbsp;object;&nbsp;<span class="comment">//&nbsp;对象を無効化</span><br />
</code>
<br />

<br />
　invalidate 演算子を用いなくても、对象は必要とされなくなった時点で削除されます。このとき、無効化されていなければ、その時点で無効化されます。<br />
　TJS2 ではいつ对象が削除されるかの明確な規定が無く、削除や無効化は「いつでもおこりうる」ことになります。したがって、無効化されてない对象は削除時に無効化されるため、思わぬ時点で finalize 方法が呼ばれてしまう可能性があります。これを避けるためにも、对象を使い終わったら invalidate 演算子で無効化することをおすすめします。<br />
<br />
<br /><div class="note"><div class="notehead"><span class="noteheadspan">Note</span></div>
　invalidate 演算子は C++ の delete 演算子に近い働きをします。<br />
　TJS2 の delete 演算子は C++ の delete 演算子と違い、メンバやローカル变量を削除するための演算子です。对象自体を無効化したり削除したりはしませんが、メンバやローカル变量を削除したことにより結果的に对象の無効化や削除を引き起こすことはあります。<br />
</div><br />
</div></div>
<h1><a id="id57" name="id57">对象へのアクセス</a>
</h1><div class="para"><div>
　作成した对象のメンバ变量、方法、メンバ属性には、<a id="id58" name="id58" class="targanchor"><dfn>.</dfn></a> (メンバ選択) 演算子 または <a id="id59" name="id59" class="targanchor"><dfn>[ ]</dfn></a> (間接メンバ選択演算子) を用いてアクセスします。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj=new&nbsp;MyLayer(window,window.prmaryLayer)<br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;方法の呼び出し&nbsp;&nbsp;obj['method1']()&nbsp;でも同じ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.num&nbsp;=&nbsp;3;&nbsp;<span class="comment">//&nbsp;メンバ变量へ代入&nbsp;&nbsp;obj['num']=3&nbsp;でも同じ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.prop1++;&nbsp;<span class="comment">//&nbsp;メンバ属性にアクセス&nbsp;&nbsp;obj['prop1']++&nbsp;でも同じ</span><br />
</code>
<br />

</div></div>
<h1><a id="id60" name="id60">クロージャ</a>
</h1><div class="para"><div>
　作成した对象の方法やメンバ属性は、そのメンバがどの对象のメンバであるかの信息を持った状態で对象に登録されています。<br />
　そのため、方法やメンバ属性を对象外に持ち出して、それを使用しても、元の对象に対するアクセスを行うことになります。この機能をクロージャと呼びます。また、アクセス先の对象を<a id="id61" name="id61" class="targanchor"><dfn>コンテキスト</dfn></a>と呼びます。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;FooBarClass();&nbsp;<span class="comment">//&nbsp;对象を作成</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method();&nbsp;<span class="comment">//&nbsp;对象の方法を普通に呼び出す</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;objmethod&nbsp;=&nbsp;obj.method;&nbsp;<span class="comment">//&nbsp;对象の方法への参照を&nbsp;objmethod&nbsp;に代入</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;objmethod();&nbsp;<span class="comment">//&nbsp;objmethod&nbsp;を呼び出すが、obj.method()&nbsp;と同じく、obj&nbsp;に対するアクセスとなる</span><br />
</code>
<br />

<br />
　<a id="id62" name="id62" class="targanchor"><dfn>incontextof</dfn></a> 演算子は、どの对象のメンバであるか、の信息を変更し、任意のコンテキスト上で方法を実行するための方法を提供します。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;(objmethod&nbsp;incontextof&nbsp;obj2)();&nbsp;<span class="comment">//&nbsp;obj2&nbsp;に対する操作になる</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;(objmethod&nbsp;incontextof&nbsp;this)();&nbsp;<span class="comment">//&nbsp;this&nbsp;に対する操作になる</span></code>
<br />

</div></div>

<h1><a id="id63" name="id63">継承</a>
</h1><div class="para"><div>
　キーワード <a id="id64" name="id64" class="targanchor"><dfn>extends</dfn></a> を用いると、类を別の类から継承させることができます。継承とは、継承元の类のメンバを引き継ぐことです。<br />
　継承する元となる类のことを<a id="id65" name="id65" class="targanchor"><dfn>スーパー类</dfn></a>、継承した类のことを<a id="id66" name="id66" class="targanchor"><dfn>サブ类</dfn></a>と呼びます。<br />
　以下のようにして类を宣言します。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class1&nbsp;<span class="comment">//&nbsp;スーパー类</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class1()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;method1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class2&nbsp;extends&nbsp;Class1<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class2()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.Class1();&nbsp;<span class="comment">//&nbsp;Class1&nbsp;コンストラクタを呼ぶ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Class2();&nbsp;<span class="comment">//&nbsp;Class2&nbsp;对象を作成</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;Class2&nbsp;は&nbsp;Class1&nbsp;の&nbsp;method1&nbsp;を継承しているので使用することができる</span><br />
</code>
<br />

　上記の例では、Class2 が Class1 を継承しています。Class2 は Class1 から<a id="id67" name="id67" class="targanchor"><dfn>派生</dfn></a>している、とも言います。<br />
　Class2 のコンストラクタ内では Class1 のコンストラクタを、Class2 の finalize では Class1 の finalize を呼んでいます。<em>サブ类が、これらの方法内でスーパー类の該当する同方法を呼び出さなかった場合の動作は未定义</em> ( というか現バージョンでは呼んだかどうかチェックしていない ) ですので、必ず記述するようにしてください。<br />
<br />
　サブ类からスーパー类を参照するためには、上記の例のようにキーワード <a id="id68" name="id68" class="targanchor"><dfn>super</dfn></a> を使用することができます。このキーワードはサブ类内でのみ使用可能で、スーパー类を表すものです。<br />
<br />
　継承が行われている場合の、new 演算子での对象の初期化の順序は以下の通りです。<br />
<br />
<ol><li>まず空の对象が作成される</li><li>方法、属性が登録される ( スーパー类から先に、サブ类に向かって )</li><li>メンバ变量が作成される ( スーパー类から先に、サブ类に向かって )</li><li>サブ类のコンストラクタが呼ばれる</li><li>( サブ类のコンストラクタ内から ) スーパー类のコンストラクタが呼ばれる</li></ol></div></div>
<h1><a id="id69" name="id69">多重継承</a>
</h1><div class="para"><div>
　extends の後に、スーパー类名を複数記述すると、多重継承を行わせることができます。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;SubClass&nbsp;extends&nbsp;ClassA,&nbsp;ClassB<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;SubClass()&nbsp;<span class="comment">//&nbsp;SubClass&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassA();&nbsp;<span class="comment">//&nbsp;ClassA&nbsp;コンストラクタを呼ぶ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassB();&nbsp;<span class="comment">//&nbsp;ClassB&nbsp;コンストラクタを呼ぶ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.ClassA.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.ClassB.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
</code>
<br />

　super キーワードが使えないため、明示的に类を指定しなければなりません。例のように スーパー类の方法を呼ぶときに global. をわざわざつけて类にアクセスするのは、サブ类内で単に ClassA と記述すると ClassA のコンストラクタのことを指すからです。类そのものは global に登録されるため、global. を用いて类にアクセスします。<br />
<br />
　多重継承が行われている場合の、new 演算子での对象の初期化の順序は多重継承を行っていないときのそれと同じすが、スーパー类の方法、属性の登録の順番は、extends キーワードの後に書いた順に行われます。継承元の类間で同名の方法や属性があった場合は、後に書いたほうが優先されます。隠れてしまった方法や属性には、global.ClassA.hiddenMethod() のように明示的に类名を書いてアクセスする事ができます。<br />
</div></div>
<h1><a id="id70" name="id70">オーバーライド</a>
</h1><div class="para"><div>
　サブ类でスーパー类の方法やメンバ属性と同名のものを宣言すると、スーパー类の方法を隠すことができます。これをオーバーライドと呼びます。<br />
　上記の説明の中にでてきた finalize 方法は、スーパー类の finalize 方法をオーバーライドしています。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class1&nbsp;<span class="comment">//&nbsp;スーパー类</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class1()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;method1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class2&nbsp;extends&nbsp;Class1<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class2()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;コンストラクタ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.Class1();&nbsp;<span class="comment">//&nbsp;Class1&nbsp;コンストラクタを呼ぶ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;Class1.method1&nbsp;をオーバーライド</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(略)&nbsp;return&nbsp;super.method1();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Class2();&nbsp;<span class="comment">//&nbsp;Class2&nbsp;对象を作成</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;Class2&nbsp;の&nbsp;method1&nbsp;が呼ばれる</span><br />
</code>
<br />

　サブ类の方法や属性では super キーワードを用いてスーパー类の方法や属性にアクセスすることができます。<br />
<br />
　メンバ变量をオーバーライドすることはできません。メンバ变量は一つの对象に対して登録されるため、サブ类とスーパー类で同名のメンバ函数があると
サブ类の变量がスーパー类の变量を上書きしてしまいます。<br />
</div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
