<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!-- generated by to_html.pl from TJSTips.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>TJSをもっと使うために</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关参考标准样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="主页" />
</head>
<body>
<h1><a id="id202" name="id202">TJS2とKAG</a>
</h1><div class="para"><div>
　TJS ( TJS2 ) は吉里吉里本体が直接理解できる脚本言語で、JavaScript や JAVA ににています。KAG はこの TJS 脚本で記述されています。<br />
　TJS 脚本は KAG が理解する ( 抽象的な ) シナリオよりもより系统側に近い ( 具体的な ) 記述をすることが可能で、扱いは難しくなりますができることの幅はぐっと広がります。<br />
<br />
　KAG には eval emb link if タグなどの exp 属性、各タグの cond 属性、エンティティ ( &amp; 付きのタグの属性 ) などなど、「TJS式」を指定する場面がいくつかあります。<br />
　TJS式を使うと、普通は KAG の裏に隠れている 吉里吉里に比較的簡単にアクセスすることができます。<br />
　また、iscript タグは、TJS2 脚本を直接実行することができます。これにより、高度な処理を実行したり、KAGの機能を拡張したりすることができます。<br />
<br />
　TJS2 の細かい文法关于は TJS2 のリファレンスを、吉里吉里本体の機能关于は吉里吉里２のリファレンスをご覧ください。<br />
</div></div>
<h1><a id="id203" name="id203">KAG の对象構造</a>
</h1><div class="para"><div>
　KAG それ自体は TJS2 脚本で記述されているため、( 良くも悪くも ) KAG の内部構造に直接アクセスすることができます。<br />
　KAG の管理する对象の变量に值を書き込む事などは相当注意したほうが良いですが、KAG 内部の变量を参照してより高度なシナリオ記述に応用することもできます。<br />
<br />
<dl>
<dt><a id="id204" name="id204" class="targanchor"><dfn>KAGWindow 类</dfn></a>の对象</dt>
<dd>　KAGWindow 类 ( MainWindow.tjs に記述 ) は、KAG の窗口を管理するための类で、この类の对象がグローバル变量の <code class="inlinecode"><a id="id205" name="id205" class="targanchor"><dfn>kag</dfn></a></code> としてアクセスできます。<br />
　たとえば、KAGWindow 类の <code class="inlinecode">skipMode</code> という变量 ( 現在どのようなモードでスキップ処理中かが入っている变量 ) にアクセスするには <code class="inlinecode"><a id="id206" name="id206" class="targanchor"><dfn>kag.skipMode</dfn></a></code> とします。</dd>
<dt><a id="id207" name="id207" class="targanchor"><dfn>背景レイヤ</dfn></a></dt>
<dd>　背景レイヤは <a id="id208" name="id208" class="targanchor"><dfn>BaseLayer 类</dfn></a> ( GraphicLayer.tjs に記述 ) の对象です。<br />
　表画面の背景レイヤは <code class="inlinecode"><a id="id209" name="id209" class="targanchor"><dfn>kag.fore.base</dfn></a></code>、裏画面の背景レイヤは <code class="inlinecode"><a id="id210" name="id210" class="targanchor"><dfn>kag.back.base</dfn></a></code> でアクセスできます。</dd>
<dt><a id="id211" name="id211" class="targanchor"><dfn>前景レイヤ</dfn></a></dt>
<dd>　前景レイヤは <a id="id212" name="id212" class="targanchor"><dfn>CharacterLayer 类</dfn></a> ( GraphicLayer.tjs に記述 ) の对象です。<br />
　表画面の前景レイヤは <code class="inlinecode"><a id="id213" name="id213" class="targanchor"><dfn>kag.fore.layers</dfn></a>[n]</code>、裏画面の前景レイヤは <code class="inlinecode"><a id="id214" name="id214" class="targanchor"><dfn>kag.back.layers</dfn></a>[n]</code> でアクセスできます ( n は前景レイヤ番号 0 ～ )。</dd>
<dt><a id="id215" name="id215" class="targanchor"><dfn>メッセージレイヤ</dfn></a></dt>
<dd>　メッセージレイヤは <a id="id216" name="id216" class="targanchor"><dfn>MessageLayer 类</dfn></a> ( MessageLayer.tjs に記述 ) の对象です。<br />
　表画面のメッセージレイヤは <code class="inlinecode"><a id="id217" name="id217" class="targanchor"><dfn>kag.fore.messages</dfn></a>[n]</code>、裏画面のメッセージレイヤは <code class="inlinecode"><a id="id218" name="id218" class="targanchor"><dfn>kag.back.messages</dfn></a>[n]</code> でアクセスできます ( n はメッセージレイヤ番号 0 ～ )。<br />
　<code class="inlinecode"><a id="id219" name="id219" class="targanchor"><dfn>kag.current</dfn></a></code> は現在操作対象となっているメッセージレイヤを表します。</dd>
<dt><a id="id220" name="id220" class="targanchor"><dfn>メッセージレイヤ内の对象</dfn></a></dt>
<dd>　メッセージレイヤ内に作成した、グラフィカルボタン、エディット、チェックボックスなどにアクセスするにはメッセージレイヤの links を使います。<br />
　links は数组对象で、リンク、グラフィカルボタン、エディット、チェックボックスなどが作成された順に、それぞれを管理する对象への参照が格納されています。そのうち、グラフィカルボタン、エディット、チェックボックス 关于はさらにそのなかの object 变量にアクセスすることによって各类の对象に直接アクセスできます。<br />
　たとえば、表画面のメッセージレイヤ0に以下のような記述があって、<br />

<br />
<code class="bq">@cm<br />
@edit&nbsp;length=420&nbsp;name=&quot;f.name&quot;<br />
</code>
<br />

    　このエディットにフォーカスを设置する ( 键盘から入力できるようにする ) にはさらに<br />

<br />
<code class="bq">@eval&nbsp;exp=&quot;kag.fore.messages[0].links[0].object.focus()&quot;<br />
</code>
<br />

　と記述することができます ( エディットを表示してユーザに入力をすぐに促したいときに便利 )。</dd>
<dt><a id="id221" name="id221" class="targanchor"><dfn>効果音缓冲区</dfn></a></dt>
<dd>　効果音缓冲区は <a id="id222" name="id222" class="targanchor"><dfn>SESoundBuffer 类</dfn></a> ( SE.tjs に記述 ) の对象です。<br />
　<code class="inlinecode"><a id="id223" name="id223" class="targanchor"><dfn>kag.se</dfn></a>[n]</code> でアクセスできます ( n は効果音缓冲区番号 0 ～ )。</dd>
<dt><a id="id224" name="id224" class="targanchor"><dfn>BGM 对象</dfn></a></dt>
<dd>　BGM 对象は <a id="id225" name="id225" class="targanchor"><dfn>BGM 类</dfn></a> ( BGM.tjs に記述 ) の对象です。<br />
　<code class="inlinecode"><a id="id226" name="id226" class="targanchor"><dfn>kag.bgm</dfn></a></code> でアクセスできます。</dd>
<dt><a id="id227" name="id227" class="targanchor"><dfn>菜单</dfn></a></dt>
<dd>　菜单对象には <code class="inlinecode"><a id="id228" name="id228" class="targanchor"><dfn>kag.menu</dfn></a></code> でアクセスできます。<code class="inlinecode">kag.menu</code> は
MenuItem 类の对象で、<code class="inlinecode">kag.menu</code> それ自体は菜单バーを
示しており、その子に登録されたアイテムが菜单バーに並ぶことになります。<br />
　菜单項目は Menus.tjs で作成していていますが、Menus.tjs を直接書き換えると
KAG系统のアップデートなどでいちいち書き換えなければならなくなるので、後述するように
AfterInit.tjs を作成してそこに変更点を記述すると楽です。</dd></dl></div></div>

<h1><a id="id229" name="id229">TJS を使うときの注意</a>
</h1><div class="para"><div>
　KAG が栞に保存しない物に直接手を加えると、KAG が栞を読み込んでもそこの部分を再現できません。<br />
　KAG 插件の onStore や onRestore をフックして栞に信息を保存するようにすれば問題ないのですが、そうしない場合は注意する必要があります。<br />
　特に Layer 类に属する描画方法などを使って、KAG の管理する背景レイヤや前景レイヤの内容に変更を加える場合などは注意が必要です。KAG は、レイヤにどのような画像が読み込まれていたかまでは記録しますが、レイヤに加えられた描画や変更までは記録しません。ですので、そのような状態で「栞を保存可能なラベル」を通過し、そこで栞を保存し、その栞を読み出しても、レイヤに加えた変更は再現できないことになります。<br />
　このような場合は、次に「栞を保存可能なラベル」を通過するまでに画像をクリアしたり別の画像を読み込むなどして KAG が管理しきれる状態に戻しておくか、あるいは「栞を保存可能なラベル」を書かない、などで回避することができます。<br />
　TJS を使う場合は、栞との関連关于十分注意してください。<br />
</div></div>
<h1><a id="id230" name="id230">式中の演算や条件判断、表示に使うもの</a>
</h1><div class="para"><div>
<dl>
<dt><code class="inlinecode"><a id="id231" name="id231" class="targanchor"><dfn>&amp;&amp;</dfn></a></code> と <code class="inlinecode"><a id="id232" name="id232" class="targanchor"><dfn>||</dfn></a></code></dt>
<dd>　この二つは演算子で、<code class="inlinecode">&amp;&amp;</code> は「かつ」を表し、<code class="inlinecode">||</code> は「または」を表します。<br />
　たとえば、<code class="inlinecode">f.flag1</code> が 1 で、かつ、<code class="inlinecode">f.flag2</code> が 2 の場合、という条件で何かをやりたい場合は、<br />
<br />
<code class="inlinecode">[if exp=&quot;f.flag1==1 &amp;&amp; f.flag2==1&quot;]</code><br />
<br />
　と書くことができます。<br />
　また、f.flag1 が 1 または 2 または 3 の場合、という条件の場合は、<br />
<br />
<code class="inlinecode">[if exp=&quot;f.flag1==1 || f.flag1==2 || f.flag1==3&quot;]</code><br />
<br />
　と書くことができます ( f.flag1 が整数ならば <code class="inlinecode">f.flag1&gt;=1 &amp;&amp; f.flag1&lt;=3</code> とも書けますが )。<br />
　普通の数式で足し算よりもかけ算を優先して計算しないとならないように、<code class="inlinecode">&amp;&amp;</code> と <code class="inlinecode">||</code> には優先順位に違いがあって、<code class="inlinecode">&amp;&amp;</code> の方が優先されます。<br />
　ですので、たとえば <code class="inlinecode">f.flag1</code> が 1 の場合で、かつ、<code class="inlinecode">f.flag2</code> が 3 または 5 のとき、という場合は、<br />
<br />
<code class="inlinecode">[if exp=&quot;f.flag1==1 &amp;&amp; (f.flag2==3 || f.flag2==5)&quot;]</code><br />
<br />
　のように ( ) カッコでくくらなければなりません。</dd>
<dt><code class="inlinecode"><a id="id233" name="id233" class="targanchor"><dfn>random</dfn></a></code> と <code class="inlinecode"><a id="id234" name="id234" class="targanchor"><dfn>intrandom</dfn></a></code></dt>
<dd>　random は 0 以上 1 未満の実数の乱数となります。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@eval&nbsp;exp=&quot;f.ransuu&nbsp;=&nbsp;random&quot;</code>
<br />

<br />
　上記の例のようにすると、f.ransuu には 0 以上 1 未満の実数の乱数が入ります。<br />
<br />
　これに対し、intrandom は指定值以上、指定值以下の整数の乱数を返す函数です。<br />
<br />
書式 : <code class="inlinecode">intrandom(<em>最小值</em>, <em>最大值</em>)</code><br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@eval&nbsp;exp=&quot;f.ransuu&nbsp;=&nbsp;intrandom(0,&nbsp;5)&quot;</code>
<br />

<br />
　上記の例
のようにすると 0 以上 5 以下の整数の乱数が f.ransuu に入ります。</dd>
<dt><code class="inlinecode"><a id="id235" name="id235" class="targanchor"><dfn>length</dfn></a></code></dt>
<dd>　length は、字符串の長さを得ることのできるものです。使い方は、字符串の代入された变量の後に . (ドット) を書き、続けて length と書きます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[if&nbsp;exp=&quot;f.namae.length&gt;=8&quot;]名前が長すぎます。[l][jump&nbsp;target=*input][endif]</code>
<br />

<br />
　上記の例では、f.namae の長さが8文字以上だった場合に「名前が長すぎます。」と表示し、*input ラベルにジャンプします。<br />
　文字は半角、全角問わず、一文字は一文字として数えられます。これは他の字符串を扱う機能でも同じです。</dd>
<dt><code class="inlinecode"><a id="id236" name="id236" class="targanchor"><dfn>substring</dfn></a></code></dt>
<dd>　substring は、字符串の一部分(部分字符串)を取り出すことのできるものです。<br />
　使い方は、字符串の代入された变量 ( または字符串を表すもの ) のあとに . (ドット) を書き、続けて<br />
<br />
<code class="inlinecode">substring(<em>切り取り開始位置</em>, <em>切り取る長さ</em>)</code><br />
<br />
　の書式で記述します。切り取り開始位置は 0 が先頭を表します。<br />
<br />
　たとえば、f.furigana 变量の２番目の文字を取り出したい場合、<code class="inlinecode">f.furigana.substring(1, 1)</code> で取り出すことができます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@emb&nbsp;exp=&quot;f.furigana.substring(1,&nbsp;1)&quot;</code>
<br />

<br />
　上記の例では、f.furigana 变量の２番目の文字を表示します。</dd>
<dt><code class="inlinecode"><a id="id237" name="id237" class="targanchor"><dfn>indexOf</dfn></a></code></dt>
<dd>　indexOf (索引・オブ) は、字符串中の部分字符串が最初に現れる位置を得ることができます。使い方をかえれば、ある字符串中に他の字符串が入っているかどうかを調べることができます。<br />
<br />
書式 : <code class="inlinecode"><em>字符串</em>.indexOf(<em>部分字符串</em>)</code><br />
<br />
　たとえば、字符串が <code class="inlinecode">&quot;ABCDEFGHIJKL&quot;</code> で、部分字符串が <code class="inlinecode">&quot;ABC&quot;</code> であった場合、<code class="inlinecode">&quot;ABCDEFGHIJKL&quot;.indexOf(&quot;ABC&quot;)</code> は <em>0</em> になります。部分字符串が <code class="inlinecode">&quot;BCD&quot;</code> の場合は <em>1</em>、<code class="inlinecode">&quot;DEF&quot;</code> の場合は <em>3</em> になります。
　もし、部分字符串が字符串中に現れなかった場合は <em>-1</em> になりますので、部分字符串が字符串の一部であるかどうかを判定するには -1 と比較すればいいことになります。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[if&nbsp;exp=&quot;'尼屁尻'.indexOf(f.objname)!=-1&quot;]～～[endif]</code>
<br />

<br />
　上記例では、<code class="inlinecode">f.objname</code> が <code class="inlinecode">&quot;尼&quot; &quot;屁&quot; &quot;尻&quot; &quot;尼屁&quot; &quot;屁尻&quot; &quot;尼屁尻&quot;</code> のいずれかであった場合に <code class="inlinecode">endif</code> までを実行します。<br />
　これを、<code class="inlinecode">&quot;尼屁&quot; &quot;屁尻&quot; &quot;尼屁尻&quot;</code> では NG にしたい場合 ( <code class="inlinecode">&quot;尼&quot; &quot;屁&quot; &quot;尻&quot;</code> の場合のみ OK にしたい場合 )、<code class="inlinecode">'尼屁尻'</code>のそれぞれを <code class="inlinecode">f.objname</code> 内では現れることのない文字(や記号) で区切ることによって実現できます。<br />
　たとえば、\v という特殊な制御記号をつかって区切ると、上記の例は<br />
<br />
<code class="inlinecode">[if exp=&quot;'尼\v屁\v尻'.indexOf(f.objname)!=-1&quot;]～～[endif]</code><br />
とかくことができます ( \v は通常、f.objname 内には現れないから )。<br />
<br />
　下記例では、f.itemname 内に 'コップ' という字符串が含まれている場合に endif までを実行します。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[if&nbsp;exp=&quot;f.itemname.indexOf('コップ')!=-1&quot;]～～[endif]</code>
<br />

</dd>
<dt><a id="id238" name="id238" class="targanchor"><dfn>正規表現</dfn></a></dt>
<dd>　正規表現パターン ( / と / で囲まれた部分 ) を使って正規表現パターンによる字符串の分解や検査を行うことができます。<br />
　正規表現パターンそのものは Perl の正規表現によく似ています ( 使い方は違いますが正規表現パターンはほぼ互換です )。<br />
<br />
　字符串が目的のパターンに適合しているかどうかを調べるには <code class="inlinecode"><a id="id239" name="id239" class="targanchor"><dfn>test</dfn></a></code> を使います。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[if&nbsp;exp=&quot;/[^0-9]/.test(f.nyuryoku)&quot;]入力された文字に数字以外が混じっています[endif]</code>
<br />

<br />
　上記の例のようにして test を使います。test はパターンに合致すると真を、合致しないと偽を返す函数(正規表現对象の方法)です。上記の例では、<code class="inlinecode">[^0-9]</code> つまり数字以外が混じっているかどうかを検査する正規表現パターンを用いて、<code class="inlinecode">f.nyuryoku</code> に数字以外の文字が混じっているかを検査しています。<br />
<br />
　字符串を分解するには <code class="inlinecode"><a id="id240" name="id240" class="targanchor"><dfn>match</dfn></a></code> を使います。<code class="inlinecode">match</code> は数组对象を返します。パターンに合致しなかった場合は数组の要素数 ( <code class="inlinecode">count</code> ) が 0 になります。それ以外の場合、要素 0 はマッチした部分全体、要素 1 からあとはパターン中の ( ) (カッコ) に対応してマッチした部分が返されます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[eval&nbsp;exp=&quot;f.matched&nbsp;=&nbsp;/([0-9０-９]+)[-－]([0-9０-９]+)/.match(f.input)&quot;]<br />
[if&nbsp;exp=&quot;f.matched.count&nbsp;==&nbsp;0&quot;]「数值-数值」の形式で入力してください。[jump&nbsp;target=*input][endif]<br />
[eval&nbsp;exp=&quot;f.s1&nbsp;=&nbsp;str2num(f.matched[1]),&nbsp;f.s2&nbsp;=&nbsp;str2num(f.matched[2])&quot;]<br />
</code>
<br />

　上記の例では、<code class="inlinecode">f.input</code> が「数值-数值」の形式に合致しているかをテストして、合致していれば - (ハイフン) の前の部分の <code class="inlinecode">f.s1</code> に、後の部分を <code class="inlinecode">f.s2</code> に、数值に変換してから代入しています。</dd>
<dt><code class="inlinecode"><a id="id241" name="id241" class="targanchor"><dfn>str2num</dfn></a></code></dt>
<dd>　str2num は、字符串を数值に変換します。<br />
<br />
書式 : <code class="inlinecode">str2num(<em>字符串または字符串の入った变量</em>)</code><br />
<br />
　単項の <code class="inlinecode">+</code> 演算子と違うのは、<code class="inlinecode">str2num</code> は、全角の数字であっても数值に変換できるということです。input タグのように、ユーザが全角で数值を入力してしまう可能性のある場合に使用できると思います。数值として認識できない字符串が渡された場合は 0 になります。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[input&nbsp;name=&quot;f.kazu&quot;&nbsp;prompt=&quot;数值を入力してください&quot;][emb&nbsp;exp=&quot;f.kazu=str2num(f.kazu)&quot;]</code>
<br />

</dd>

<dt><code class="inlinecode"><a id="id242" name="id242" class="targanchor"><dfn>kansuuji</dfn></a></code> と <code class="inlinecode"><a id="id243" name="id243" class="targanchor"><dfn>kansuuji_simple</dfn></a></code></dt>
<dd>　<code class="inlinecode">kansuuji</code> は、指定された数值を漢数字表記にします。<code class="inlinecode">kansuuji_simple</code> も同様ですが、桁を表す単位をつけません。<br />
　9223372036854775807 という数值を、<code class="inlinecode">kansuuji</code> の場合は &quot;九百二十二京三千三百七十二兆三百六十八億五千四百七十七万五千八百七&quot; に、<code class="inlinecode">kansuuji_simple</code> の場合は &quot;九二二三三七二〇三六八五四七七五八〇七&quot; に変換します。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@emb&nbsp;exp=&quot;kansuuji(f.num)&quot;<br />
</code>
<br />

　上記の例では、f.num を漢数字表記にして表示しています。<br />
</dd>
<dt><code class="inlinecode"><a id="id244" name="id244" class="targanchor"><dfn>number_format</dfn></a></code></dt>
<dd>　<code class="inlinecode">number_format</code> は、指定された数值を3桁ごとに , (カンマ) で区切った表記にします。たとえば、9223372036854775807 という数值ならば &quot;9,223,372,036,854,775,807&quot; に変換されます。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@emb&nbsp;exp=&quot;number_format(f.num)&quot;<br />
</code>
<br />

　上記の例では、f.num を 3桁ごとにカンマで区切って表示しています。<br />
</dd>

<dt><code class="inlinecode"><a id="id245" name="id245" class="targanchor"><dfn>Storages.addAutoPath</dfn></a> と <a id="id246" name="id246" class="targanchor"><dfn>System.exePath</dfn></a></code></dt>
<dd>　Storages.addAutoPath は、自動検索パスを追加します。<br />
　System.exePath は、吉里吉里実行可能文件の設置されている文件夹を示します。<br />
　詳しくは吉里吉里 SDK Help を参照していただきたいのですが、これらを使うとアーカイブや文件夹に自動検索パスを设置できます。<br />
　自動検索パスは、わざわざ文件夹を指定しなくても、文件を自動的に見つけてくるための仕組みです。標準では、system image scenario bgimage fgimage bgm sound rule others video のすべてが设置されていますが、Storages.addAutoPath で追加することができます。<br />
System.exePath は、吉里吉里実行可能文件のある文件夹です。<br />
<br />
　たとえば、吉里吉里実行可能文件の直下に cgdata という文件夹があって、そこの中を自動検索パスに指定したい場合は、<br />
<br />
<code class="inlinecode">[eval exp=&quot;Storages.addAutoPath(System.exePath + 'cgdata/')&quot;]</code><br />
<br />
　とします ( cgdata の後の二つの / は必ずつけてください )。<br />
<br />
　もし、吉里吉里実行可能文件と同じ場所に cgdata.xp3 というアーカイブ文件があって、このアーカイブ内に自動検索パスを指定したい場合は、<br />
<br />
<code class="inlinecode">[eval exp=&quot;Storages.addAutoPath(System.exePath + 'cgdata.xp3&gt;')&quot;]</code><br />
<br />
　とします。cgdata.xp3 の後の記号は '&gt;' です。アーカイブ内に検索パスを指定する場合は &gt; で、文件夹内に検索パスを指定する場合は / です。<br />
　アーカイブの後の記号は 吉里吉里２ 2.19 beta 14 で '#' から '&gt;' に変更となりました。<br />
</dd>
<dt><code class="inlinecode"><a id="id247" name="id247" class="targanchor"><dfn>Storages.searchCD</dfn></a></code></dt>
<dd>　Storages.searchCD は、引数に渡されたボリュームラベルを持つ CD が挿入されたドライブの文字を返します。<br />
　たとえば、上記 Storages.addAutoPath と組み合わせて、FOO_BAR_DISC というボリュームラベルを持つ CD-ROM 内の image という文件夹に自動検索パスを追加したい場合、<br />
<br />
<code class="inlinecode">[eval exp=&quot;Storages.addAutoPath(Storages.searchCD('FOO_BAR_DISC') + ':image/')&quot;]</code><br />
<br />
　と記述することができます。<br />
<br />
　Stotages.searchCD は、指定されたボリュームラベルを持つ CD が挿入されたドライブが見つからない場合は空字符串を返すので、たとえば指定の CD-ROM がドライブに挿入されていることを確認するために、<br />
<br />
<code class="inlinecode">[if exp=&quot;Storages.searchCD('FOO_BAR_DISC') == ''&quot;]CDが挿入されていません[endif]</code><br />
<br />
　のように記述することができます。</dd>
<dt><code class="inlinecode"><a id="id248" name="id248" class="targanchor"><dfn>System.readRegValue</dfn></a></code></dt>
<dd>　System.readRegValue では、レジストリに書き込まれた值を読むことができます。たとえば、HKEY_LOCAL_MACHINE\SOFTWARE\Dee\kirikiri\installpath を f.installpath に読み込むには、<br />
<br />
<code class="inlinecode">[eval exp=&quot;f.installpath = System.readRegValue('HKEY_LOCAL_MACHINE\\SOFTWARE\\Dee\\kirikiri\\installpath')&quot;]</code><br />
　とします。'' で囲まれた中では \ は \\ と記述しなければならないことに注意してください。<br />
　字符串と数值の值のみを読むことができます。レジストリに值が存在しない場合は void になるので、<code class="inlinecode">===</code> (識別演算子) を用いて<br />
<br />
<code class="inlinecode">[if exp=&quot;f.installpath === void&quot;]インストールされていません[endif]</code><br />
<br />
　のような記述をすることができます。</dd>
<dt><code class="inlinecode"><a id="id249" name="id249" class="targanchor"><dfn>kag.clickCount</dfn></a></code></dt>
<dd>　画面上を鼠标でクリックするたびに 1 が加算されます。この变量には值を代入してもかまいませんので、0 に设置しておけば、鼠标がクリックされたことを、この变量が 0 以外の数值になっていることで知ることができます。</dd>
<dt><code class="inlinecode"><a id="id250" name="id250" class="targanchor"><dfn>kag.lastMouseDownX</dfn></a> と <a id="id251" name="id251" class="targanchor"><dfn>kag.lastMouseDownY</dfn></a></code></dt>
<dd>　これらは、最後に鼠标がクリックされた座標を表しています。kag.lastMouseDownX は最後にクリックされた X 座標、kag.lastMouseDownY は最後にクリックされた Y 座標です。</dd>
<dt><code class="inlinecode"><a id="id252" name="id252" class="targanchor"><dfn>kag.lastWaitTime</dfn></a></code></dt>
<dd>　wait タグを mode=until で使用したとき、実際に wait タグがまとうとした時間が设置されます。すでにまとうとしていた時間が過ぎていた場合は 0 になりますので、wait タグの直後でこの变量が 0 でないかどうかを判断すれば、処理が追いついているかどうかを判断することができます。<br />
　ちなみに、クリックなどで wait が中断された場合は、この变量は正確に待っていた時間を表す訳ではありません ( 中断がなかったとした場合の時間を表しています )。</dd>
<dt><code class="inlinecode"><a id="id253" name="id253" class="targanchor"><dfn>kag.skipMode</dfn></a></code></dt>
<dd>　現在のスキップのモードを表す值が入っています。0=スキップなし, 1=クリック待ち記号まで, 2=改ページ待ち記号まで, 3=次の停止まで、となっています。<br />
　たとえば、声や効果音などをスキップ中には再生したくない場合は、<br />
<br />
<code class="inlinecode">@playse cond=&quot;kag.skipMode&lt;=1&quot; storage=&quot;hogehoeg.wav&quot;</code><br />
<br />
　のように記述することができます。</dd>
<dt><code class="inlinecode"><a id="id254" name="id254" class="targanchor"><dfn>kag.autoMode</dfn></a></code></dt>
<dd>　自動読みすすみの処理中の時に真、それ以外の時に偽になっています。<br />
　たとえば、声や効果音などの終了を、自動読みすすみの時のみに処理したい場合は、<br />
<br />
<code class="inlinecode">@ws cond=&quot;kag.autoMode&quot;</code><br />
<br />
　のように記述することができます。</dd>
<dt><code class="inlinecode"><a id="id255" name="id255" class="targanchor"><dfn>kag.getBookMarkPageName</dfn></a></code></dt>
<dd>　<code class="inlinecode">kag.getBookMarkPageName</code> は、非フリーセーブモードにおいて、引数に指定された番号 ( 0 ～ ) で示された、栞の場所の名前を得ることが出来ます。<br />
　KAG の菜单からではなく、画面上で栞を示してユーザーにたどる栞を選ばせたいときに使うことが出来ます。<br />
　<code class="inlinecode">kag.restoreBookMark</code> と組み合わせて使います。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[locate&nbsp;x=10&nbsp;y=100][link&nbsp;exp=&quot;kag.restoreBookMark(0)&quot;][emb&nbsp;exp=&quot;kag.getBookMarkPageName(0)&quot;][endlink]<br />
[locate&nbsp;x=10&nbsp;y=130][link&nbsp;exp=&quot;kag.restoreBookMark(1)&quot;][emb&nbsp;exp=&quot;kag.getBookMarkPageName(1)&quot;][endlink]<br />
(以下同様)<br />
</code>
<br />

</dd>
<dt><code class="inlinecode"><a id="id256" name="id256" class="targanchor"><dfn>mp</dfn></a></code></dt>
<dd>　<code class="inlinecode">mp</code> は、マクロ中にて、マクロに渡された属性が記録された辞書数组を表します。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@macro&nbsp;name=fimg<br />
@image&nbsp;*<br />
@eval&nbsp;exp=&quot;sf[mp.storage]=1&quot;<br />
@endmacro<br />
</code>
<br />

　上記の例では、たとえば <code class="inlinecode">@fimg layer=base page=fore storage=&quot;bg_03&quot;</code> と記述された場合、このマクロが実行されている間は <code class="inlinecode">mp.layer</code> は <code class="inlinecode">'base'</code>、<code class="inlinecode">mp.page</code> は <code class="inlinecode">'fore'</code>、<code class="inlinecode">'mp.storage'</code> は <code class="inlinecode">'bg_03'</code> になっています。つまり、マクロに渡された属性を <code class="inlinecode">mp.</code> の後に指定することによって、その属性の值を得ることができます。<br />
　このマクロを <code class="inlinecode">@fimg layer=base page=fore storage=&quot;bg_03&quot;</code> として使用した場合、exp タグで <code class="inlinecode">sf[mp.storage]=1</code> が実行されるため、<code class="inlinecode">sf['bg_03']</code> が 1 になります。<br />
　このマクロは、image/img タグの代わりに使うことにより、表示した画像を自動的に系统变量に記録するマクロとして使用することができます。</dd>
<dt><code class="inlinecode"><a id="id257" name="id257" class="targanchor"><dfn>System.getKeyState</dfn></a></code></dt>
<dd>　<code class="inlinecode">System.getKeyState</code> は、現在その時点で、指定されたキーが押されているかどうかを判断することができます。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@jump&nbsp;target=*shift_key_pressed&nbsp;cond=&quot;System.getKeyState(VK_SHIFT)&quot;<br />
;&nbsp;シフトキーが押されていれば、*shift_key_pressed&nbsp;にジャンプする<br />
</code>
<br />

詳しくは吉里吉里２ SDK Help を参照してください。<br />
<br />
　KAG3はゲームパッド(ジョイスティック)からの入力を受け付けますが、ゲームバッドの上に物が乗っかっている、あるいはジョイスティックの軸の調整が不十分という場合には、正常に作品の操作をできない場合があります。<br />
　作品開始時にゲームパッドのボタンが押されていれば、ユーザに対して警告をすることができます (通常、作品開始時にゲームパッドのボタンが押されていることはなく、押されているとなれば、ユーザの意図しない理由で押されたままになっている可能性が高いため)。<br />
　USB接続のゲームパッドなどでは下記の例では「押されっぱなし」の検出がうまくいかないかもしれませんので、適宜ドキュメントなどでの補足を推奨します。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@if&nbsp;exp=&quot;System.getKeyState(VK_PADANY)&quot;<br />
@wait&nbsp;time=500<br />
@if&nbsp;exp=&quot;System.getKeyState(VK_PADANY)&quot;<br />
;&nbsp;VK_PADANYでは、ゲームパッドのいずれかのボタンが押されている時に真を返す<br />
;&nbsp;500ms(0.5秒間)をすぎてもなお押されているようならばメッセージを表示<br />
ゲームパッド(ジョイスティック)のボタンが押されたままになっています。<br />
ゲームパッドの上に物が乗っかっていないか、あるいはジョイスティックの<br />
軸の調整がされているかを確認してください。<br />
状況が改善しない場合は、ゲームパッド(ジョイスティック)を抜いてください。<br />
それでも状況が改善しなければ、ゲームを終了し、「エンジン设置」を起動し、<br />
「入力-パッド使用可否」の设置を「使用しない」に设置してください。<br />
[s]<br />
@endif<br />
@endif<br />
</code>
<br />

</dd>

</dl>

</div></div>
<h1><a id="id258" name="id258">リンクやボタンの exp 属性などに指定するもの</a>
</h1><div class="para"><div>
<dl>
<dt><code class="inlinecode"><a id="id259" name="id259" class="targanchor"><dfn>System.shellExecute</dfn></a></code></dt>
<dd>　System.shellExecute は、引数に指定された文件を開きます。URL を指定するとブラウザが開くので、link タグなどを使ってこの式を実行させれば、Web ページへのリンクなどを作成することが出来ます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[link&nbsp;exp=&quot;System.shellExecute('http://www.yahoo.co.jp/')&quot;]http://www.yahoo.co.jp/[endlink]</code>
<br />

</dd>
<dt><code class="inlinecode"><a id="id260" name="id260" class="targanchor"><dfn>kag.close</dfn></a></code> と <code class="inlinecode"><a id="id261" name="id261" class="targanchor"><dfn>kag.shutdown</dfn></a></code></dt>
<dd>　kag.close は、KAG を終了させます。終了確認を行う设置にしている場合は終了確認があります。<br />
　kag.shutdown も KAG を終了させますが、終了確認はありません。<br />
　なお、終了に System.exit() を使用すると、系统变量が保存されずに終了される場合があるので<em>使用しないでください</em>。また、これらは eval タグの exp 属性では指定しないでください (代わりに close タグを使用してください)。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[link&nbsp;exp=&quot;kag.close()&quot;]終了[endlink]<br />
[link&nbsp;exp=&quot;kag.shutdown()&quot;]終了[endlink]<br />
</code>
<br />

</dd>
<dt><code class="inlinecode"><a id="id262" name="id262" class="targanchor"><dfn>kag.restoreBookMark</dfn></a></code> と <code class="inlinecode"><a id="id263" name="id263" class="targanchor"><dfn>kag.storeBookMark</dfn></a></code></dt>
<dd>　kag.restoreBookMark は、非フリーセーブモードにおいて、引数に指定された番号で示された栞をたどります。<br />
　同様に、kag.storeBookMark は、引数に指定された番号で示された栞を挟みます。<br />
　ただし、これを直接呼び出すと、[store] タグで栞の使用が禁止されていても栞の操作が出来てしまいます。<br />
　これらは、成功すると真を、失敗すると偽を返します。<br />
　例は kag.getBookMarkPageName の物を参照してください。</dd>
<dt><code class="inlinecode"><a id="id264" name="id264" class="targanchor"><dfn>kag.loadBookMarkFromFileWithAsk</dfn></a></code> と <code class="inlinecode"><a id="id265" name="id265" class="targanchor"><dfn>kag.saveBookMarkToFileWithAsk</dfn></a></code></dt>
<dd>　kag.loadBookMarkFromFileWithAsk は、フリーセーブモードにおいて、文件選択对话框ボックスを表示し、ユーザに栞数据を選択させます。ユーザが OK ボタンを押すとその栞から再開します。<br />
　同様に、kag.saveBookMarkToFileWithAsk は、文件選択对话框ボックスを表示し、栞を保存します。<br />
　これらは、成功すると真を、ユーザがキャンセルをするか、あるいは失敗すると偽を返します。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[link&nbsp;exp=&quot;kag.loadBookMarkFromFileWithAsk()&quot;]栞をたどる[endlink]<br />
[link&nbsp;exp=&quot;kag.saveBookMarkToFileWithAsk()&quot;]栞をはさむ[endlink]<br />
</code>
<br />

</dd>
<dt><code class="inlinecode"><a id="id266" name="id266" class="targanchor"><dfn>kag.callExtraConductor</dfn></a></code></dt>
<dd>　kag.callExtraConductor は、TJS の制御によって KAG のシナリオをサブルーチンとして呼び出すために用います。この方法でシナリオを呼び出すときは、シナリオがクリック待ちや s タグで停止中である必要があります ( kag.inStable や KAG 插件の onStableStateChanged で知ることができます )。<br />
　kag.callExtraConductor には引数が３つあります。<br />
　最初の引数は呼び出すシナリオ文件です。次の引数は呼び出すラベルです。<br />
　３番目の引数は省略可能ですが、KAG のシナリオから戻ったときに実行する函数/方法を指定します。必要ない場合は指定しなくてかまいません。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[button&nbsp;graphic=&quot;showhist&quot;&nbsp;exp=&quot;kag.callExtraConductor('rclick.ks',&nbsp;'*showhist')&quot;]</code>
<br />

<br />
　これで呼び出すサブルーチンの書き方は、右クリックサブルーチンの書き方に準じます。<br />
　右クリックサブルーチン中や、すでにこの機能を使って KAG のシナリオを呼び出している最中では、この機能は使用できません。</dd>
<dt><code class="inlinecode"><a id="id267" name="id267" class="targanchor"><dfn>kag.se[n].play</dfn></a></code></dt>
<dd>　効果音缓冲区の play 方法は、効果音の再生を開始します。<br />
　以下の形式で指定します。<br />
<br />
　
<br />
<code class="bq">kag.se[効果音缓冲区番号].play(%[storage:&nbsp;再生する効果音の文件名,&nbsp;loop:&nbsp;ループするか]);</code>
<br />

<br />
　これをたとえば、以下の例のように link タグの onenter 属性に指定すれば、選択肢の上に鼠标光标が乗ったときに効果音を発音することができます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[link&nbsp;target=*foo&nbsp;onenter=&quot;kag.se[0].play(%[storage:'select.wav',&nbsp;loop:&nbsp;false])&quot;]選択肢～[endlink]</code>
<br />

<br />
　この例では、効果音缓冲区 0 番で select.wav を、ループをせずに再生します。他にも TJS の制御で効果音を鳴らしたいときに便利です。</dd></dl></div></div>
<h1><a id="id268" name="id268">数组</a>
</h1><div class="para"><div>
　吉里吉里２/KAG3 では数组を簡単に使うことができます。<br />
　数组を使う場合は、最初に <code class="inlinecode"><a id="id269" name="id269" class="targanchor"><dfn>[ ]</dfn></a></code> を使って数组を宣言しないとなりません。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[eval&nbsp;exp=&quot;f.hairetsu&nbsp;=&nbsp;[]&quot;]</code>
<br />

<br />
　上記の例では、<code class="inlinecode">f.hairetsu</code> を数组として使うことを宣言しています。もしすでに <code class="inlinecode">f.hairetsu</code> が数组だったり、他の数值とか字符串であったとすると <code class="inlinecode">f.hairetsu</code> の内容は消去されてしまいますので注意してください。<br />
　系统变量などで数组を使いたい場合は、初期状態では变量はすべて void が代入されていると見なされることを利用して、<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[eval&nbsp;exp=&quot;sf.hairetsu&nbsp;=&nbsp;[]&nbsp;if&nbsp;sf.hairetsu&nbsp;===&nbsp;void&quot;]</code>
<br />

<br />
　とすれば、初回起動時だけ数组を宣言することができます。２回目以降でも数组が消去されることはありません。<br />
<br />
　数组に值を代入するには <code class="inlinecode">[ ]</code> を使います。<code class="inlinecode">[ ]</code> 内には添え字 ( 要素番号 ) を書きます。添え字は 0 から始まります。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[eval&nbsp;exp=&quot;f.hairetsu[0]&nbsp;=&nbsp;'zero',&nbsp;f.hairetsu[1]&nbsp;=&nbsp;'one'&quot;]</code>
<br />

<br />
　上記の例では <code class="inlinecode">f.hairetsu[0]</code> に 'zero' を、<code class="inlinecode">f.hairetsu[1]</code> に 'one' を代入しています。<br />
　数组の要素数は宣言する必要はありません。必要な大きさまで自動的に拡張されます。数组の要素数を得たり设置したりするには <code class="inlinecode"><a id="id270" name="id270" class="targanchor"><dfn>count</dfn></a></code> 属性を用いて <code class="inlinecode">f.hairetsu.count</code> などとします。 <br />
<br />
　表示も同様に行えます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />0&nbsp;:&nbsp;[emb&nbsp;exp=&quot;f.hairetsu[0]&quot;]&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;[emb&nbsp;exp=&quot;f.hairetsu[1]&quot;]</code>
<br />

<br />
　２次元数组を用いるのはすこし難しいですが、例だけ挙げておきます。<br />

<br />
<code class="bq">@iscript<br />
<span class="comment">//&nbsp;１次元目の要素数が&nbsp;5&nbsp;の２次元数组を作成する</span><br />
f.twodim&nbsp;=&nbsp;[]&nbsp;if&nbsp;f.twodim&nbsp;===&nbsp;void;&nbsp;<span class="comment">//&nbsp;twodim&nbsp;に１次元目の数组を作成</span><br />
for(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;5;&nbsp;i++)&nbsp;f.twodim[i]&nbsp;=&nbsp;[]&nbsp;if&nbsp;f.twodim[i]&nbsp;===&nbsp;void;<br />
<span class="comment">//&nbsp;この状態で&nbsp;f.twodim[0]&nbsp;～&nbsp;f.twodim[4]&nbsp;がそれぞれ数组なので</span><br />
<span class="comment">//&nbsp;f.twodim[0][3]&nbsp;や&nbsp;f.twodim[4][2]&nbsp;などと指定できる</span><br />
@endscript<br />
<br />
<span class="comment">//&nbsp;あるいは、単純にたとえば１次元目の要素数が5の数组を作成するならば</span><br />
f.twodim&nbsp;=&nbsp;[&nbsp;[],&nbsp;[],&nbsp;[],&nbsp;[],&nbsp;[]&nbsp;];<br />
<span class="comment">//&nbsp;(&nbsp;数组を&nbsp;[]&nbsp;で作成するときにその中に初期要素をカンマで区切って指定できるが、</span><br />
<span class="comment">//&nbsp;&nbsp;&nbsp;そのときに初期要素として数组を入れ子に指定する&nbsp;)</span><br />
</code>
<br />

</div></div>
<h1><a id="id271" name="id271">辞書数组</a>
</h1><div class="para"><div>
　吉里吉里２/KAG3 では辞書数组も使うことができます。<br />
　辞書数组 ( 連想数组とも呼びます ) とは、名前と、それに対応する值の組を覚えることのできる数组です。<br />
　辞書数组を使う場合は、数组と同じように、最初に <code class="inlinecode"><a id="id272" name="id272" class="targanchor"><dfn>%[ ]</dfn></a></code> を使って数组を宣言しないとなりません。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[eval&nbsp;exp=&quot;f.dict&nbsp;=&nbsp;%[]&quot;]</code>
<br />

<br />
　上記の例では、f.dict を辞書数组として使うことを宣言しています。もしすでに f.hairetsu が辞書数组だったりしたばあいの注意は数组と同じです。<br />
<br />
　辞書数组に值を代入するにも <code class="inlinecode">[ ]</code> を使います ( <code class="inlinecode">%[ ]</code> ではありません )。<code class="inlinecode">[ ]</code> 内には「名前」となるものを書きます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[eval&nbsp;exp=&quot;f.dict['zero']&nbsp;=&nbsp;0,&nbsp;f.dict['one']&nbsp;=&nbsp;1&quot;]</code>
<br />

<br />
　上記の例では <code class="inlinecode">f.dict['zero']</code> に <code class="inlinecode">0</code> を、<code class="inlinecode">f.dict['one']</code> に <code class="inlinecode">1</code> を代入しています。普通の数组と違うのは字符串を <code class="inlinecode">[ ]</code> 内に指定することです。<br />
<br />
　表示も同様に行えます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />zero&nbsp;:&nbsp;[emb&nbsp;exp=&quot;f.dict['zero']&quot;]&nbsp;&nbsp;&nbsp;&nbsp;one&nbsp;:&nbsp;[emb&nbsp;exp=&quot;f.dict['one']&quot;]</code>
<br />

<br />
　ちなみに <code class="inlinecode">[ ]</code> ではなく <code class="inlinecode">.</code> を使うこともできます。<code class="inlinecode">f.dict['zero']</code> は <code class="inlinecode">f.dict.zero</code> 、<code class="inlinecode">f.dict['one']</code> は <code class="inlinecode">f.dict.one</code> と記述することができます ( ただし . の次には「予約語」や「变量名として使えない名前」が来ることはできません )。<br />
<br />
　実は KAG の <code class="inlinecode">f</code> や <code class="inlinecode">sf</code> といったもの自体も辞書数组で、<code class="inlinecode">f.dict</code> としたばあいは、辞書数组の中の <code class="inlinecode">'dict'</code> という名前のついた值にアクセスしていたことになります ( もちろん、<code class="inlinecode">f['dict']</code> でもアクセスできます )。<br />
</div></div>

<h1><a id="id273" name="id273">日付/時刻を得る</a>
</h1><div class="para"><div>
　現在の日付や時刻を得るには以下のようにします。<br />

<br />
<code class="bq">[iscript]<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;↑&nbsp;&nbsp;endscript&nbsp;の中を&nbsp;{&nbsp;&nbsp;}&nbsp;で囲むのは&nbsp;この中で宣言された变量を</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;ローカル变量にするため&nbsp;(&nbsp;そうしないとグローバル变量になる&nbsp;)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;d&nbsp;=&nbsp;new&nbsp;Date();&nbsp;<span class="comment">//&nbsp;Date&nbsp;类の对象を作成</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Date&nbsp;类の对象は、作成時に引数に何も指定しなければ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;作成時点の現在時刻を保持している</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;f.year&nbsp;=&nbsp;d.getYear();&nbsp;&nbsp;<span class="comment">//&nbsp;f.year&nbsp;に&nbsp;年</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;f.month&nbsp;=&nbsp;d.getMonth()&nbsp;+&nbsp;1;&nbsp;<span class="comment">//&nbsp;f.month&nbsp;に&nbsp;月</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;f.date&nbsp;=&nbsp;d.getDate();&nbsp;<span class="comment">//&nbsp;f.date&nbsp;に&nbsp;日</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;f.hours&nbsp;=&nbsp;d.getHours();&nbsp;<span class="comment">//&nbsp;f.hours&nbsp;に&nbsp;時</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;f.minutes&nbsp;=&nbsp;d.getMinutes();&nbsp;<span class="comment">//&nbsp;f.minutes&nbsp;に&nbsp;分</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;f.seconds&nbsp;=&nbsp;d.getSeconds();&nbsp;<span class="comment">//&nbsp;f.seconds&nbsp;に&nbsp;秒</span><br />
}<br />
[endscript]<br />
</code>
<br />

</div></div>
<h1><a id="id274" name="id274">process</a>
</h1><div class="para"><div>
　<code class="inlinecode">kag.process</code> は、シナリオを指定した位置から実行します。<br />
　最初の引数は読み込むシナリオ文件名です。空字符串を指定すると現在のシナリオ文件が使用されます。<br />
　２番目の引数は、実行を開始するラベルです。空字符串を指定するとシナリオ文件の先頭から実行します。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />kag.process('',&nbsp;'*label2')<br />
kag.process('scenario4.ks',&nbsp;'*label5')<br />
</code>
<br />

<br />
　たとえシナリオが実行中であろうとも、強制的にそのラベルに飛ぶので注意してください。<br />
</div></div>

<h1><a id="id275" name="id275">leftClickHook, rightClickHook, keyDownHook</a>
</h1><div class="para"><div>
　KAG は、左クリックされたとき、右クリックされたとき、キーが押されたときのそれぞれの場合に、登録した函数を呼び出す機能があり、フックと呼んでいます。<br />
　フックは、複数の函数を登録できるように数组になっています。それぞれ <code class="inlinecode">kag.leftClickHook</code>、<code class="inlinecode">kag.rightClickHook</code>、<code class="inlinecode">kag.keyDownHook</code> でアクセスできるようになっています。<br />
　これらに登録した函数で true が返されると、KAG はもともとその機能に割り当てられていた機能を実行しません。たとえば、R キーが押されたとき、keyDownHook に登録された函数が true を返すと、元々の機能である「メッセージ履歴を表示する」の機能は実行されなくなります。<br />
<br />
　leftClickHook と rightClickHook には、呼び出される函数に引数はありません。<br />
　leftClickHook は、Enter キーや Space キー等でも発生します。また、鼠标で選択肢などをクリックしたときには発生しません。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@iscript<br />
function&nbsp;myLeftClickHook()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;kag.process('',&nbsp;'*label');<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br />
}<br />
@endscript<br />
@eval&nbsp;exp=&quot;kag.leftClickHook.add(myLeftClickHook)&quot;<br />
@s<br />
<br />
*label<br />
@eval&nbsp;exp=&quot;kag.leftClickHook.remove(myLeftClickHook)&quot;<br />
やあー。<br />
@s<br />
</code>
<br />

<br />
　上記の例では、クリックされると *label が実行されます。<br />
　強制的に実行が *label に移るので注意してください。トランジションや自動移動を実行中等の場合は stoptrans や stopmove タグで実行を停止したほうが安全です。<br />
<br />
　keyDownHook は、呼び出される函数には２つ引数が渡されて、一つ目は押されたキーの仮想キーコード、二つ目はそのキーが押されていたときに同時に押されていたシフト系のキーの状態です。詳しくは吉里吉里２ SDK Help を参照してください。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@iscript<br />
function&nbsp;myKeyDownHook(key,&nbsp;shift)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(key&nbsp;==&nbsp;#'R')<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;R&nbsp;のキーが押されたら</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kag.process('',&nbsp;'*label');<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
@endscript<br />
@eval&nbsp;exp=&quot;kag.keyDownHook.add(myKeyDownHook)&quot;<br />
@s<br />
<br />
*label<br />
@eval&nbsp;exp=&quot;kag.keyDownHook.remove(myKeyDownHook)&quot;<br />
やあー。<br />
@s<br />
</code>
<br />

</div></div>
<h1><a id="id276" name="id276">touchImages</a>
</h1><div class="para"><div>
　<code class="inlinecode">System.touchImages</code> は、画像をキャッシュに読み込みます。<br />
　詳しくは 吉里吉里２ドキュメントの System.touchImages をご覧ください。この方法は、たとえばなにかのウェイトで時間があいたときを利用して、画像を先読みしておく用途に使えます。<br />
　KAG で使う場合は、前景、背景画像 ( ただし key 属性を指定しないものに限る ) に対して有効です。image や img タグの storage 属性に指定するものと同じ物を storages 引数に数组にして指定してください。<br />
　第２引数は -2*1024*1024 あたりを指定しておくと良いようです。<br />
　第３引数には、待つ時間 - 200ms あたりを指定しておくと良いようです。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@resetwait<br />
@eval&nbsp;exp=&quot;System.touchImages(['24_5',&nbsp;'24_4',&nbsp;'uni',&nbsp;'24'],&nbsp;-2*1024*1024,&nbsp;800)&quot;<br />
@wait&nbsp;mode=until&nbsp;time=1000<br />
</code>
<br />

<br />
　ただし、この方法は、画像がキャッシュに入るということは保証しないという、不確定的なものです。ですから、絶対に画像を先に読んでおかなければいけない用途には使うべきではありません。そのような用途には後述の assignImages の項で説明する方法を使う方が確実です。<br />
</div></div>
<h1><a id="id277" name="id277">assignImages</a>
</h1><div class="para"><div>
　<code class="inlinecode">assignImages</code> は、レイヤの画像を他のレイヤにコピーします。<br />
　たとえば、<br />
<br />
<code class="inlinecode">@eval exp=&quot;kag.fore.base.assignImages(kag.fore.layers[0])&quot;</code><br />
<br />
　とすれば、表前景レイヤ 0 に読み込まれている画像を表背景レイヤにコピーすることができます。<br />
　assignImages は実際には画像の数据をコピーはせず、「コピー元とコピー先の画像が同じになった」という印を付けるだけなので高速です。デモシーンなどで、シーンの途中で画像を読み込むときのタイムロスが問題になるような場合に、あらかじめ画像を非表示の前景レイヤなどに読み込んでおいてから、必要なときに背景レイヤなどにコピーする用途に使えます。<br />
</div></div>

<h1><a id="id278" name="id278">hact タグの応用</a>
</h1><div class="para"><div>
　hact タグはメッセージ履歴をクリックしたときに任意の TJS 式を実行できるようにするもので、音声履歴 ( 声つきのゲームなどでメッセージ履歴をクリックしたときにそのメッセージに対応する音声を再生できるようにするもの ) を実装することができます。<br />
　以下は、それを実現するための例で、音声を再生するためのマクロ pv と、音声を停止するためのマクロ sv を定義するものです。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />@iscript<br />
function&nbsp;stopAllVoices()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;2&nbsp;～&nbsp;6&nbsp;のすべての効果音を停止する</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;for(var&nbsp;i&nbsp;=&nbsp;2;&nbsp;i&nbsp;&lt;=&nbsp;6;&nbsp;i++)&nbsp;kag.se[i].stop();<br />
}<br />
function&nbsp;playVoice(buf,&nbsp;storage)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;効果音缓冲区&nbsp;buf&nbsp;にて&nbsp;storage&nbsp;を再生する</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;KAG&nbsp;がスキップ処理中の場合は処理を行わない</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;if(!kag.skipMode)<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopAllVoices();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kag.se[buf].play(%[&nbsp;storage&nbsp;:&nbsp;storage&nbsp;]);<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
function&nbsp;createHistoryActionExp(buf,&nbsp;storage)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;メッセージ履歴をクリックしたときに実行する&nbsp;TJS&nbsp;式を生成する</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;stopAllVoices(),&nbsp;kag.se[&quot;&nbsp;+&nbsp;buf&nbsp;&nbsp;+&quot;].play(%[&nbsp;storage&nbsp;:&nbsp;'&quot;&nbsp;+&nbsp;storage&nbsp;+&nbsp;&quot;'&nbsp;])&quot;;<br />
}<br />
@endscript<br />
@macro&nbsp;name=pv<br />
@hact&nbsp;exp=&quot;&amp;createHistoryActionExp(mp.b,&nbsp;mp.s)&quot;<br />
@eval&nbsp;exp=&quot;playVoice(mp.b,&nbsp;mp.s)&quot;<br />
@endmacro<br />
@macro&nbsp;name=waitvoices<br />
@ws&nbsp;buf=2<br />
@ws&nbsp;buf=3<br />
@ws&nbsp;buf=4<br />
@ws&nbsp;buf=5<br />
@ws&nbsp;buf=6<br />
@endmacro<br />
@macro&nbsp;name=sv<br />
@endhact<br />
@waitvoices&nbsp;cond=&quot;kag.autoMode&quot;<br />
@eval&nbsp;exp=&quot;stopAllVoices()&quot;<br />
@endmacro<br />
</code>
<br />

<br />
　createHistoryActionExp 函数では、hact タグの exp 属性に渡すための TJS 式を生成しています。ここで生成した TJS 式が実行されることになります。<br />
<br />
　このマクロを使った例は以下のようになります。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />[pv&nbsp;b=2&nbsp;s=hoge.ogg]ほげ[l][sv][r]<br />
[pv&nbsp;b=3&nbsp;s=hogera.ogg]ほげら[l][sv][r]<br />
[pv&nbsp;b=4&nbsp;s=hogemoge.ogg]ほげもげ[p][sv]<br />
</code>
<br />

</div></div>


<h1><a id="id279" name="id279">初期化時に実行される脚本</a>
</h1><div class="para"><div>
　KAG は系统のカスタマイズのために、初期化のいくつかの段階において 任意の TJS 脚本を実行する機能があります。現バージョンでは以下の方法が用意されています。<br />
<br />
<dl>
<dt><a id="id280" name="id280" class="targanchor"><dfn>Override.tjs</dfn></a></dt>
<dd>　この文件は MainWindow.tjs が読み込まれた後に、もし存在すれば実行されます。初期状態ではこの文件は存在しないので、新しく作成してください。</dd>
<dt><a id="id281" name="id281" class="targanchor"><dfn>AfterInit.tjs</dfn></a></dt>
<dd>　すべての初期化が終わり、 first.ks が実行される直前に実行されます。この文件も初期状態では存在しないので、新しく作成してください。</dd>
<dt>「<a id="id282" name="id282" class="targanchor"><dfn>追加の设置</dfn></a>」</dt>
<dd>　Config.tjs 内には、いくつか「◆ 窗口や動作の追加の设置」など、「追加の设置」を記述できるところがあります。そこに記述した内容は Config.tjs の実行される各段階で実行されます。</dd></dl></div></div>
<h1><a id="id283" name="id283">菜单のカスタマイズ</a>
</h1><div class="para"><div>
　菜单項目に、たとえば、単純な on/off だけの设置項目を追加するには、AfterInit.tjs に以下のような内容を書きます。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />kag.menu.insert(kag.optionsMenu&nbsp;=<br />
&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;KAGMenuItem(this,&nbsp;&quot;効果(&amp;G)&quot;,&nbsp;0,&nbsp;void,&nbsp;false),&nbsp;2);<br />
kag.optionsMenu.stopRecur&nbsp;=&nbsp;true;<br />
<br />
kag.optionsMenu.add(<br />
&nbsp;&nbsp;&nbsp;&nbsp;kag.doTransMenuItem&nbsp;=&nbsp;new&nbsp;KAGMenuItem(<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;画面切り替えを行う(&amp;T)&quot;,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function(sender)&nbsp;{&nbsp;sf.dotrans&nbsp;=&nbsp;sender.checked&nbsp;=&nbsp;!sf.dotrans;&nbsp;},<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false));<br />
<br />
if(sf.dotrans&nbsp;===&nbsp;void)&nbsp;sf.dotrans&nbsp;=&nbsp;true;<br />
kag.doTransMenuItem.checked&nbsp;=&nbsp;sf.dotrans;<br />
<br />
kag.optionsMenu.add(<br />
&nbsp;&nbsp;&nbsp;&nbsp;kag.playSEItem&nbsp;=&nbsp;new&nbsp;KAGMenuItem(<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;効果音を再生する(&amp;S)&quot;,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function(sender)&nbsp;{&nbsp;sf.playse&nbsp;=&nbsp;sender.checked&nbsp;=&nbsp;!sf.playse;&nbsp;},<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false));<br />
<br />
if(sf.playse&nbsp;===&nbsp;void)&nbsp;sf.playse&nbsp;=&nbsp;true;<br />
kag.playSEItem.checked&nbsp;=&nbsp;sf.playse;<br />
</code>
<br />

<br />
　<code class="inlinecode">kag.menu.insert(kag.optionsMenu = new KAGMenuItem(this, &quot;効果(&amp;G)&quot;, 0, void, false), 2);</code> では、KAG の菜单バーに「効果」菜单を挿入しています。kag.optionMenu がその「効果」菜单の对象になります。insert 方法の第２引数は、菜单項目を挿入する位置です。<br />
　次の行ではその对象の stopRecur を true に设置していますが、これは kag.internalSetMenuAccessibleAll で不必要な菜单アイテムの検索を行わないようにするためです。<br />
<br />
　その kag.optioneMenu に、add 方法で子の菜单項目を作成しています。<br />
<br />
　KAGMenuItem の第４引数は、菜单アイテムがクリックされたときに実行する式を指定します。<br />
<br />
　<code class="inlinecode">if(sf.dotrans === void) sf.dotrans = true;</code> では、sf.dotrans が void ( つまり、何も值が無い状態 ) の時に、初期值を入れています。<code class="inlinecode">kag.doTransMenuItem.checked = sf.dotrans;</code> では、菜单アイテムのチェックの初期状態を设置しています。系统变量に記録しているため、プログラムを終了しても次回に设置が引き継がれます。<br />
<br />
　あとは sf.dotrans や sf.playse に現在の菜单の状態が記録されているので、<br />
<br />
<code class="inlinecode">@playse storage=&quot;kon.wav&quot; cond=&quot;sf.playse&quot;</code><br />
　のようにして使用することができます。<br />
<br />
　応用でいろいろできると思います。<br />
</div></div>

<h1><a id="id284" name="id284">KAG用插件を書く</a>
</h1><div class="para"><div>
　<a id="id285" name="id285" class="targanchor"><dfn>KAGPlugin 类</dfn></a> のサブ类を作り、KAG に登録することで KAG の機能を拡張する插件を作ることができます。<br />
　サンプルが KAG の配布文件とともに配布されていると思うので参照してみてください。<br />
</div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
